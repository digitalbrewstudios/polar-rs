/*
 * Polar API
 *
 * Read the docs at https://polar.sh/docs/api-reference
 *
 * The version of the OpenAPI document: 0.1.0
 *
 * Generated by: https://openapi-generator.tech
 */

use crate::models;
use serde::{Deserialize, Serialize};

/// CheckoutPublic : Checkout session data retrieved using the client secret.
#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct CheckoutPublic {
    /// The ID of the object.
    #[serde(rename = "id")]
    pub id: String,
    /// Creation timestamp of the object.
    #[serde(rename = "created_at")]
    pub created_at: String,
    #[serde(rename = "modified_at", deserialize_with = "Option::deserialize")]
    pub modified_at: Option<String>,
    /// Key-value object storing custom field values.
    #[serde(rename = "custom_field_data", skip_serializing_if = "Option::is_none")]
    pub custom_field_data: Option<std::collections::HashMap<String, models::CustomFieldDataValue>>,
    /// Payment processor used.
    #[serde(rename = "payment_processor")]
    pub payment_processor: models::PaymentProcessor,
    ///          Status of the checkout session.          - Open: the checkout session was opened.         - Expired: the checkout session was expired and is no more accessible.         - Confirmed: the user on the checkout session clicked Pay. This is not indicative of the payment's success status.         - Failed: the checkout definitely failed for technical reasons and cannot be retried. In most cases, this state is never reached.         - Succeeded: the payment on the checkout was performed successfully.         
    #[serde(rename = "status")]
    pub status: models::CheckoutStatus,
    /// Client secret used to update and complete the checkout session from the client.
    #[serde(rename = "client_secret")]
    pub client_secret: String,
    /// URL where the customer can access the checkout session.
    #[serde(rename = "url")]
    pub url: String,
    /// Expiration date and time of the checkout session.
    #[serde(rename = "expires_at")]
    pub expires_at: String,
    /// URL where the customer will be redirected after a successful payment.
    #[serde(rename = "success_url")]
    pub success_url: String,
    #[serde(rename = "return_url", deserialize_with = "Option::deserialize")]
    pub return_url: Option<String>,
    #[serde(rename = "embed_origin", deserialize_with = "Option::deserialize")]
    pub embed_origin: Option<String>,
    /// Amount in cents, before discounts and taxes.
    #[serde(rename = "amount")]
    pub amount: i32,
    #[serde(
        rename = "seats",
        default,
        with = "::serde_with::rust::double_option",
        skip_serializing_if = "Option::is_none"
    )]
    pub seats: Option<Option<i32>>,
    #[serde(
        rename = "price_per_seat",
        default,
        with = "::serde_with::rust::double_option",
        skip_serializing_if = "Option::is_none"
    )]
    pub price_per_seat: Option<Option<i32>>,
    /// Discount amount in cents.
    #[serde(rename = "discount_amount")]
    pub discount_amount: i32,
    /// Amount in cents, after discounts but before taxes.
    #[serde(rename = "net_amount")]
    pub net_amount: i32,
    #[serde(rename = "tax_amount", deserialize_with = "Option::deserialize")]
    pub tax_amount: Option<i32>,
    /// Amount in cents, after discounts and taxes.
    #[serde(rename = "total_amount")]
    pub total_amount: i32,
    /// Currency code of the checkout session.
    #[serde(rename = "currency")]
    pub currency: String,
    #[serde(
        rename = "active_trial_interval",
        deserialize_with = "Option::deserialize"
    )]
    pub active_trial_interval: Option<models::TrialInterval>,
    #[serde(
        rename = "active_trial_interval_count",
        deserialize_with = "Option::deserialize"
    )]
    pub active_trial_interval_count: Option<i32>,
    #[serde(rename = "trial_end", deserialize_with = "Option::deserialize")]
    pub trial_end: Option<String>,
    /// ID of the organization owning the checkout session.
    #[serde(rename = "organization_id")]
    pub organization_id: String,
    #[serde(rename = "product_id", deserialize_with = "Option::deserialize")]
    pub product_id: Option<String>,
    #[serde(rename = "product_price_id", deserialize_with = "Option::deserialize")]
    pub product_price_id: Option<String>,
    #[serde(rename = "discount_id", deserialize_with = "Option::deserialize")]
    pub discount_id: Option<String>,
    /// Whether to allow the customer to apply discount codes. If you apply a discount through `discount_id`, it'll still be applied, but the customer won't be able to change it.
    #[serde(rename = "allow_discount_codes")]
    pub allow_discount_codes: bool,
    /// Whether to require the customer to fill their full billing address, instead of just the country. Customers in the US will always be required to fill their full address, regardless of this setting. If you preset the billing address, this setting will be automatically set to `true`.
    #[serde(rename = "require_billing_address")]
    pub require_billing_address: bool,
    /// Whether the discount is applicable to the checkout. Typically, free and custom prices are not discountable.
    #[serde(rename = "is_discount_applicable")]
    pub is_discount_applicable: bool,
    /// Whether the product price is free, regardless of discounts.
    #[serde(rename = "is_free_product_price")]
    pub is_free_product_price: bool,
    /// Whether the checkout requires payment, e.g. in case of free products or discounts that cover the total amount.
    #[serde(rename = "is_payment_required")]
    pub is_payment_required: bool,
    /// Whether the checkout requires setting up a payment method, regardless of the amount, e.g. subscriptions that have first free cycles.
    #[serde(rename = "is_payment_setup_required")]
    pub is_payment_setup_required: bool,
    /// Whether the checkout requires a payment form, whether because of a payment or payment method setup.
    #[serde(rename = "is_payment_form_required")]
    pub is_payment_form_required: bool,
    #[serde(rename = "customer_id", deserialize_with = "Option::deserialize")]
    pub customer_id: Option<String>,
    /// Whether the customer is a business or an individual. If `true`, the customer will be required to fill their full billing address and billing name.
    #[serde(rename = "is_business_customer")]
    pub is_business_customer: bool,
    #[serde(rename = "customer_name", deserialize_with = "Option::deserialize")]
    pub customer_name: Option<String>,
    #[serde(rename = "customer_email", deserialize_with = "Option::deserialize")]
    pub customer_email: Option<String>,
    #[serde(
        rename = "customer_ip_address",
        deserialize_with = "Option::deserialize"
    )]
    pub customer_ip_address: Option<String>,
    #[serde(
        rename = "customer_billing_name",
        deserialize_with = "Option::deserialize"
    )]
    pub customer_billing_name: Option<String>,
    /// Billing address of the customer.
    #[serde(
        rename = "customer_billing_address",
        deserialize_with = "Option::deserialize"
    )]
    pub customer_billing_address: Option<Box<models::Address>>,
    #[serde(rename = "customer_tax_id", deserialize_with = "Option::deserialize")]
    pub customer_tax_id: Option<String>,
    #[serde(rename = "payment_processor_metadata")]
    pub payment_processor_metadata: std::collections::HashMap<String, String>,
    /// Determine which billing address fields should be disabled, optional or required in the checkout form.
    #[serde(rename = "billing_address_fields")]
    pub billing_address_fields: Box<models::CheckoutBillingAddressFields>,
    /// List of products available to select.
    #[serde(rename = "products")]
    pub products: Vec<models::CheckoutProduct>,
    #[serde(rename = "product", deserialize_with = "Option::deserialize")]
    pub product: Option<Box<models::CheckoutProduct>>,
    #[serde(rename = "product_price", deserialize_with = "Option::deserialize")]
    pub product_price: Option<Box<models::CheckoutProductPrice>>,
    #[serde(rename = "discount", deserialize_with = "Option::deserialize")]
    pub discount: Option<Box<models::CheckoutDiscount>>,
    #[serde(rename = "organization")]
    pub organization: Box<models::Organization>,
    #[serde(
        rename = "attached_custom_fields",
        deserialize_with = "Option::deserialize"
    )]
    pub attached_custom_fields: Option<Vec<models::AttachedCustomField>>,
}

impl CheckoutPublic {
    /// Checkout session data retrieved using the client secret.
    pub fn new(
        id: String,
        created_at: String,
        modified_at: Option<String>,
        payment_processor: models::PaymentProcessor,
        status: models::CheckoutStatus,
        client_secret: String,
        url: String,
        expires_at: String,
        success_url: String,
        return_url: Option<String>,
        embed_origin: Option<String>,
        amount: i32,
        discount_amount: i32,
        net_amount: i32,
        tax_amount: Option<i32>,
        total_amount: i32,
        currency: String,
        active_trial_interval: Option<models::TrialInterval>,
        active_trial_interval_count: Option<i32>,
        trial_end: Option<String>,
        organization_id: String,
        product_id: Option<String>,
        product_price_id: Option<String>,
        discount_id: Option<String>,
        allow_discount_codes: bool,
        require_billing_address: bool,
        is_discount_applicable: bool,
        is_free_product_price: bool,
        is_payment_required: bool,
        is_payment_setup_required: bool,
        is_payment_form_required: bool,
        customer_id: Option<String>,
        is_business_customer: bool,
        customer_name: Option<String>,
        customer_email: Option<String>,
        customer_ip_address: Option<String>,
        customer_billing_name: Option<String>,
        customer_billing_address: Option<models::Address>,
        customer_tax_id: Option<String>,
        payment_processor_metadata: std::collections::HashMap<String, String>,
        billing_address_fields: models::CheckoutBillingAddressFields,
        products: Vec<models::CheckoutProduct>,
        product: Option<models::CheckoutProduct>,
        product_price: Option<models::CheckoutProductPrice>,
        discount: Option<models::CheckoutDiscount>,
        organization: models::Organization,
        attached_custom_fields: Option<Vec<models::AttachedCustomField>>,
    ) -> CheckoutPublic {
        CheckoutPublic {
            id,
            created_at,
            modified_at,
            custom_field_data: None,
            payment_processor,
            status,
            client_secret,
            url,
            expires_at,
            success_url,
            return_url,
            embed_origin,
            amount,
            seats: None,
            price_per_seat: None,
            discount_amount,
            net_amount,
            tax_amount,
            total_amount,
            currency,
            active_trial_interval,
            active_trial_interval_count,
            trial_end,
            organization_id,
            product_id,
            product_price_id,
            discount_id,
            allow_discount_codes,
            require_billing_address,
            is_discount_applicable,
            is_free_product_price,
            is_payment_required,
            is_payment_setup_required,
            is_payment_form_required,
            customer_id,
            is_business_customer,
            customer_name,
            customer_email,
            customer_ip_address,
            customer_billing_name,
            customer_billing_address: customer_billing_address.map(Box::new),
            customer_tax_id,
            payment_processor_metadata,
            billing_address_fields: Box::new(billing_address_fields),
            products,
            product: product.map(Box::new),
            product_price: product_price.map(Box::new),
            discount: discount.map(Box::new),
            organization: Box::new(organization),
            attached_custom_fields,
        }
    }
}
