/*
 * Polar API
 *
 * Read the docs at https://polar.sh/docs/api-reference
 *
 * The version of the OpenAPI document: 0.1.0
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for typed errors of method [`customer_portal_benefit_grants_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomerPortalBenefitGrantsGetError {
    Status404(models::ResourceNotFound),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`customer_portal_benefit_grants_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomerPortalBenefitGrantsListError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`customer_portal_benefit_grants_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomerPortalBenefitGrantsUpdateError {
    Status403(models::NotPermitted),
    Status404(models::ResourceNotFound),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`customer_portal_customer_meters_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomerPortalCustomerMetersGetError {
    Status404(models::ResourceNotFound),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`customer_portal_customer_meters_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomerPortalCustomerMetersListError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`customer_portal_customer_session_introspect`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomerPortalCustomerSessionIntrospectError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`customer_portal_customers_add_payment_method`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomerPortalCustomersAddPaymentMethodError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`customer_portal_customers_confirm_payment_method`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomerPortalCustomersConfirmPaymentMethodError {
    Status400(models::CustomerNotReady),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`customer_portal_customers_delete_payment_method`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomerPortalCustomersDeletePaymentMethodError {
    Status400(models::PaymentMethodInUseByActiveSubscription),
    Status404(models::ResourceNotFound),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`customer_portal_customers_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomerPortalCustomersGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`customer_portal_customers_list_payment_methods`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomerPortalCustomersListPaymentMethodsError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`customer_portal_customers_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomerPortalCustomersUpdateError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`customer_portal_downloadables_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomerPortalDownloadablesListError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`customer_portal_license_keys_activate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomerPortalLicenseKeysActivateError {
    Status403(models::NotPermitted),
    Status404(models::ResourceNotFound),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`customer_portal_license_keys_deactivate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomerPortalLicenseKeysDeactivateError {
    Status404(models::ResourceNotFound),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`customer_portal_license_keys_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomerPortalLicenseKeysGetError {
    Status404(models::ResourceNotFound),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`customer_portal_license_keys_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomerPortalLicenseKeysListError {
    Status401(models::Unauthorized),
    Status404(models::ResourceNotFound),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`customer_portal_license_keys_validate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomerPortalLicenseKeysValidateError {
    Status404(models::ResourceNotFound),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`customer_portal_orders_confirm_retry_payment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomerPortalOrdersConfirmRetryPaymentError {
    Status404(models::ResourceNotFound),
    Status409(models::PaymentAlreadyInProgress),
    Status422(models::OrderNotEligibleForRetry),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`customer_portal_orders_generate_invoice`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomerPortalOrdersGenerateInvoiceError {
    Status422(models::Response422CustomerPortalOrdersGenerateInvoice),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`customer_portal_orders_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomerPortalOrdersGetError {
    Status404(models::ResourceNotFound),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`customer_portal_orders_get_payment_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomerPortalOrdersGetPaymentStatusError {
    Status404(models::ResourceNotFound),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`customer_portal_orders_invoice`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomerPortalOrdersInvoiceError {
    Status404(models::ResourceNotFound),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`customer_portal_orders_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomerPortalOrdersListError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`customer_portal_orders_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomerPortalOrdersUpdateError {
    Status404(models::ResourceNotFound),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`customer_portal_organizations_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomerPortalOrganizationsGetError {
    Status404(models::ResourceNotFound),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`customer_portal_seats_assign_seat`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomerPortalSeatsAssignSeatError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`customer_portal_seats_list_claimed_subscriptions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomerPortalSeatsListClaimedSubscriptionsError {
    Status401(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`customer_portal_seats_list_seats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomerPortalSeatsListSeatsError {
    Status401(),
    Status403(),
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`customer_portal_seats_resend_invitation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomerPortalSeatsResendInvitationError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`customer_portal_seats_revoke_seat`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomerPortalSeatsRevokeSeatError {
    Status401(),
    Status403(),
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`customer_portal_subscriptions_cancel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomerPortalSubscriptionsCancelError {
    Status403(models::AlreadyCanceledSubscription),
    Status404(models::ResourceNotFound),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`customer_portal_subscriptions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomerPortalSubscriptionsGetError {
    Status404(models::ResourceNotFound),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`customer_portal_subscriptions_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomerPortalSubscriptionsListError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`customer_portal_subscriptions_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomerPortalSubscriptionsUpdateError {
    Status403(models::AlreadyCanceledSubscription),
    Status404(models::ResourceNotFound),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`customer_portal_wallets_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomerPortalWalletsGetError {
    Status404(models::ResourceNotFound),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`customer_portal_wallets_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomerPortalWalletsListError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// Get a benefit grant by ID for the authenticated customer.  **Scopes**: `customer_portal:read` `customer_portal:write`
pub async fn customer_portal_benefit_grants_get(
    configuration: &configuration::Configuration,
    id: &str,
) -> Result<models::CustomerBenefitGrant, Error<CustomerPortalBenefitGrantsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/v1/customer-portal/benefit-grants/{id}",
        configuration.base_path,
        id = crate::apis::urlencode(p_path_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CustomerBenefitGrant`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CustomerBenefitGrant`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CustomerPortalBenefitGrantsGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// List benefits grants of the authenticated customer.  **Scopes**: `customer_portal:read` `customer_portal:write`
pub async fn customer_portal_benefit_grants_list(
    configuration: &configuration::Configuration,
    r#type: Option<models::BenefitTypeFilter>,
    benefit_id: Option<models::BenefitIdFilter2>,
    checkout_id: Option<models::CheckoutIdFilter1>,
    order_id: Option<models::OrderIdFilter>,
    subscription_id: Option<models::SubscriptionIdFilter>,
    page: Option<i32>,
    limit: Option<i32>,
    sorting: Option<Vec<models::CustomerBenefitGrantSortProperty>>,
) -> Result<models::ListResourceCustomerBenefitGrant, Error<CustomerPortalBenefitGrantsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_type = r#type;
    let p_query_benefit_id = benefit_id;
    let p_query_checkout_id = checkout_id;
    let p_query_order_id = order_id;
    let p_query_subscription_id = subscription_id;
    let p_query_page = page;
    let p_query_limit = limit;
    let p_query_sorting = sorting;

    let uri_str = format!(
        "{}/v1/customer-portal/benefit-grants/",
        configuration.base_path
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_benefit_id {
        req_builder = req_builder.query(&[("benefit_id", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_checkout_id {
        req_builder = req_builder.query(&[("checkout_id", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_order_id {
        req_builder = req_builder.query(&[("order_id", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_subscription_id {
        req_builder =
            req_builder.query(&[("subscription_id", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sorting {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("sorting".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "sorting",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListResourceCustomerBenefitGrant`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListResourceCustomerBenefitGrant`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CustomerPortalBenefitGrantsListError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Update a benefit grant for the authenticated customer.  **Scopes**: `customer_portal:write`
pub async fn customer_portal_benefit_grants_update(
    configuration: &configuration::Configuration,
    id: &str,
    customer_benefit_grant_update: models::CustomerBenefitGrantUpdate,
) -> Result<models::CustomerBenefitGrant, Error<CustomerPortalBenefitGrantsUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_body_customer_benefit_grant_update = customer_benefit_grant_update;

    let uri_str = format!(
        "{}/v1/customer-portal/benefit-grants/{id}",
        configuration.base_path,
        id = crate::apis::urlencode(p_path_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_customer_benefit_grant_update);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CustomerBenefitGrant`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CustomerBenefitGrant`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CustomerPortalBenefitGrantsUpdateError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a meter by ID for the authenticated customer.  **Scopes**: `customer_portal:read` `customer_portal:write`
pub async fn customer_portal_customer_meters_get(
    configuration: &configuration::Configuration,
    id: &str,
) -> Result<models::CustomerCustomerMeter, Error<CustomerPortalCustomerMetersGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/v1/customer-portal/meters/{id}",
        configuration.base_path,
        id = crate::apis::urlencode(p_path_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CustomerCustomerMeter`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CustomerCustomerMeter`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CustomerPortalCustomerMetersGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// List meters of the authenticated customer.  **Scopes**: `customer_portal:read` `customer_portal:write`
pub async fn customer_portal_customer_meters_list(
    configuration: &configuration::Configuration,
    meter_id: Option<models::MeterIdFilter>,
    query: Option<&str>,
    page: Option<i32>,
    limit: Option<i32>,
    sorting: Option<Vec<models::CustomerCustomerMeterSortProperty>>,
) -> Result<models::ListResourceCustomerCustomerMeter, Error<CustomerPortalCustomerMetersListError>>
{
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_meter_id = meter_id;
    let p_query_query = query;
    let p_query_page = page;
    let p_query_limit = limit;
    let p_query_sorting = sorting;

    let uri_str = format!("{}/v1/customer-portal/meters/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_meter_id {
        req_builder = req_builder.query(&[("meter_id", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_query {
        req_builder = req_builder.query(&[("query", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sorting {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("sorting".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "sorting",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListResourceCustomerCustomerMeter`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListResourceCustomerCustomerMeter`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CustomerPortalCustomerMetersListError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Introspect the current session and return its information.  **Scopes**: `customer_portal:read` `customer_portal:write`
pub async fn customer_portal_customer_session_introspect(
    configuration: &configuration::Configuration,
) -> Result<models::CustomerCustomerSession, Error<CustomerPortalCustomerSessionIntrospectError>> {
    let uri_str = format!(
        "{}/v1/customer-portal/customer-session/introspect",
        configuration.base_path
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CustomerCustomerSession`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CustomerCustomerSession`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CustomerPortalCustomerSessionIntrospectError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Add a payment method to the authenticated customer.  **Scopes**: `customer_portal:read` `customer_portal:write`
pub async fn customer_portal_customers_add_payment_method(
    configuration: &configuration::Configuration,
    customer_payment_method_create: models::CustomerPaymentMethodCreate,
) -> Result<
    models::CustomerPaymentMethodCreateResponse,
    Error<CustomerPortalCustomersAddPaymentMethodError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_customer_payment_method_create = customer_payment_method_create;

    let uri_str = format!(
        "{}/v1/customer-portal/customers/me/payment-methods",
        configuration.base_path
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_customer_payment_method_create);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CustomerPaymentMethodCreateResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CustomerPaymentMethodCreateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CustomerPortalCustomersAddPaymentMethodError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Confirm a payment method for the authenticated customer.  **Scopes**: `customer_portal:read` `customer_portal:write`
pub async fn customer_portal_customers_confirm_payment_method(
    configuration: &configuration::Configuration,
    customer_payment_method_confirm: models::CustomerPaymentMethodConfirm,
) -> Result<
    models::CustomerPaymentMethodCreateResponse,
    Error<CustomerPortalCustomersConfirmPaymentMethodError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_customer_payment_method_confirm = customer_payment_method_confirm;

    let uri_str = format!(
        "{}/v1/customer-portal/customers/me/payment-methods/confirm",
        configuration.base_path
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_customer_payment_method_confirm);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CustomerPaymentMethodCreateResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CustomerPaymentMethodCreateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CustomerPortalCustomersConfirmPaymentMethodError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Delete a payment method from the authenticated customer.  **Scopes**: `customer_portal:read` `customer_portal:write`
pub async fn customer_portal_customers_delete_payment_method(
    configuration: &configuration::Configuration,
    id: &str,
) -> Result<(), Error<CustomerPortalCustomersDeletePaymentMethodError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/v1/customer-portal/customers/me/payment-methods/{id}",
        configuration.base_path,
        id = crate::apis::urlencode(p_path_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CustomerPortalCustomersDeletePaymentMethodError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get authenticated customer.  **Scopes**: `customer_portal:read` `customer_portal:write`
pub async fn customer_portal_customers_get(
    configuration: &configuration::Configuration,
) -> Result<models::CustomerPortalCustomer, Error<CustomerPortalCustomersGetError>> {
    let uri_str = format!(
        "{}/v1/customer-portal/customers/me",
        configuration.base_path
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CustomerPortalCustomer`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CustomerPortalCustomer`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CustomerPortalCustomersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get saved payment methods of the authenticated customer.  **Scopes**: `customer_portal:read` `customer_portal:write`
pub async fn customer_portal_customers_list_payment_methods(
    configuration: &configuration::Configuration,
    page: Option<i32>,
    limit: Option<i32>,
) -> Result<
    models::ListResourceCustomerPaymentMethod,
    Error<CustomerPortalCustomersListPaymentMethodsError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_page = page;
    let p_query_limit = limit;

    let uri_str = format!(
        "{}/v1/customer-portal/customers/me/payment-methods",
        configuration.base_path
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListResourceCustomerPaymentMethod`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListResourceCustomerPaymentMethod`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CustomerPortalCustomersListPaymentMethodsError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Update authenticated customer.  **Scopes**: `customer_portal:write`
pub async fn customer_portal_customers_update(
    configuration: &configuration::Configuration,
    customer_portal_customer_update: models::CustomerPortalCustomerUpdate,
) -> Result<models::CustomerPortalCustomer, Error<CustomerPortalCustomersUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_customer_portal_customer_update = customer_portal_customer_update;

    let uri_str = format!(
        "{}/v1/customer-portal/customers/me",
        configuration.base_path
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_customer_portal_customer_update);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CustomerPortalCustomer`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CustomerPortalCustomer`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CustomerPortalCustomersUpdateError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// **Scopes**: `customer_portal:read` `customer_portal:write`
pub async fn customer_portal_downloadables_list(
    configuration: &configuration::Configuration,
    benefit_id: Option<models::BenefitIdFilter3>,
    page: Option<i32>,
    limit: Option<i32>,
) -> Result<models::ListResourceDownloadableRead, Error<CustomerPortalDownloadablesListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_benefit_id = benefit_id;
    let p_query_page = page;
    let p_query_limit = limit;

    let uri_str = format!(
        "{}/v1/customer-portal/downloadables/",
        configuration.base_path
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_benefit_id {
        req_builder = req_builder.query(&[("benefit_id", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListResourceDownloadableRead`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListResourceDownloadableRead`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CustomerPortalDownloadablesListError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Activate a license key instance.  > This endpoint doesn't require authentication and can be safely used on a public > client, like a desktop application or a mobile app. > If you plan to validate a license key on a server, use the `/v1/license-keys/activate` > endpoint instead.
pub async fn customer_portal_license_keys_activate(
    configuration: &configuration::Configuration,
    license_key_activate: models::LicenseKeyActivate,
) -> Result<models::LicenseKeyActivationRead, Error<CustomerPortalLicenseKeysActivateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_license_key_activate = license_key_activate;

    let uri_str = format!(
        "{}/v1/customer-portal/license-keys/activate",
        configuration.base_path
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_license_key_activate);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LicenseKeyActivationRead`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LicenseKeyActivationRead`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CustomerPortalLicenseKeysActivateError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Deactivate a license key instance.  > This endpoint doesn't require authentication and can be safely used on a public > client, like a desktop application or a mobile app. > If you plan to validate a license key on a server, use the `/v1/license-keys/deactivate` > endpoint instead.
pub async fn customer_portal_license_keys_deactivate(
    configuration: &configuration::Configuration,
    license_key_deactivate: models::LicenseKeyDeactivate,
) -> Result<(), Error<CustomerPortalLicenseKeysDeactivateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_license_key_deactivate = license_key_deactivate;

    let uri_str = format!(
        "{}/v1/customer-portal/license-keys/deactivate",
        configuration.base_path
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_license_key_deactivate);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CustomerPortalLicenseKeysDeactivateError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a license key.  **Scopes**: `customer_portal:read` `customer_portal:write`
pub async fn customer_portal_license_keys_get(
    configuration: &configuration::Configuration,
    id: &str,
) -> Result<models::LicenseKeyWithActivations, Error<CustomerPortalLicenseKeysGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/v1/customer-portal/license-keys/{id}",
        configuration.base_path,
        id = crate::apis::urlencode(p_path_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LicenseKeyWithActivations`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LicenseKeyWithActivations`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CustomerPortalLicenseKeysGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// **Scopes**: `customer_portal:read` `customer_portal:write`
pub async fn customer_portal_license_keys_list(
    configuration: &configuration::Configuration,
    benefit_id: Option<&str>,
    page: Option<i32>,
    limit: Option<i32>,
) -> Result<models::ListResourceLicenseKeyRead, Error<CustomerPortalLicenseKeysListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_benefit_id = benefit_id;
    let p_query_page = page;
    let p_query_limit = limit;

    let uri_str = format!(
        "{}/v1/customer-portal/license-keys/",
        configuration.base_path
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_benefit_id {
        req_builder = req_builder.query(&[("benefit_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListResourceLicenseKeyRead`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListResourceLicenseKeyRead`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CustomerPortalLicenseKeysListError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Validate a license key.  > This endpoint doesn't require authentication and can be safely used on a public > client, like a desktop application or a mobile app. > If you plan to validate a license key on a server, use the `/v1/license-keys/validate` > endpoint instead.
pub async fn customer_portal_license_keys_validate(
    configuration: &configuration::Configuration,
    license_key_validate: models::LicenseKeyValidate,
) -> Result<models::ValidatedLicenseKey, Error<CustomerPortalLicenseKeysValidateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_license_key_validate = license_key_validate;

    let uri_str = format!(
        "{}/v1/customer-portal/license-keys/validate",
        configuration.base_path
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_license_key_validate);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ValidatedLicenseKey`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ValidatedLicenseKey`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CustomerPortalLicenseKeysValidateError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Confirm a retry payment using a Stripe confirmation token.  **Scopes**: `customer_portal:write`
pub async fn customer_portal_orders_confirm_retry_payment(
    configuration: &configuration::Configuration,
    id: &str,
    customer_order_confirm_payment: models::CustomerOrderConfirmPayment,
) -> Result<
    models::CustomerOrderPaymentConfirmation,
    Error<CustomerPortalOrdersConfirmRetryPaymentError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_body_customer_order_confirm_payment = customer_order_confirm_payment;

    let uri_str = format!(
        "{}/v1/customer-portal/orders/{id}/confirm-payment",
        configuration.base_path,
        id = crate::apis::urlencode(p_path_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_customer_order_confirm_payment);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CustomerOrderPaymentConfirmation`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CustomerOrderPaymentConfirmation`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CustomerPortalOrdersConfirmRetryPaymentError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Trigger generation of an order's invoice.  **Scopes**: `customer_portal:read` `customer_portal:write`
pub async fn customer_portal_orders_generate_invoice(
    configuration: &configuration::Configuration,
    id: &str,
) -> Result<serde_json::Value, Error<CustomerPortalOrdersGenerateInvoiceError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/v1/customer-portal/orders/{id}/invoice",
        configuration.base_path,
        id = crate::apis::urlencode(p_path_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CustomerPortalOrdersGenerateInvoiceError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get an order by ID for the authenticated customer.  **Scopes**: `customer_portal:read` `customer_portal:write`
pub async fn customer_portal_orders_get(
    configuration: &configuration::Configuration,
    id: &str,
) -> Result<models::CustomerOrder, Error<CustomerPortalOrdersGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/v1/customer-portal/orders/{id}",
        configuration.base_path,
        id = crate::apis::urlencode(p_path_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CustomerOrder`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CustomerOrder`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CustomerPortalOrdersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get the current payment status for an order.  **Scopes**: `customer_portal:read` `customer_portal:write`
pub async fn customer_portal_orders_get_payment_status(
    configuration: &configuration::Configuration,
    id: &str,
) -> Result<models::CustomerOrderPaymentStatus, Error<CustomerPortalOrdersGetPaymentStatusError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/v1/customer-portal/orders/{id}/payment-status",
        configuration.base_path,
        id = crate::apis::urlencode(p_path_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CustomerOrderPaymentStatus`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CustomerOrderPaymentStatus`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CustomerPortalOrdersGetPaymentStatusError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get an order's invoice data.  **Scopes**: `customer_portal:read` `customer_portal:write`
pub async fn customer_portal_orders_invoice(
    configuration: &configuration::Configuration,
    id: &str,
) -> Result<models::CustomerOrderInvoice, Error<CustomerPortalOrdersInvoiceError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/v1/customer-portal/orders/{id}/invoice",
        configuration.base_path,
        id = crate::apis::urlencode(p_path_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CustomerOrderInvoice`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CustomerOrderInvoice`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CustomerPortalOrdersInvoiceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// List orders of the authenticated customer.  **Scopes**: `customer_portal:read` `customer_portal:write`
pub async fn customer_portal_orders_list(
    configuration: &configuration::Configuration,
    product_id: Option<models::ProductIdFilter>,
    product_billing_type: Option<models::ProductBillingTypeFilter>,
    subscription_id: Option<models::SubscriptionIdFilter>,
    query: Option<&str>,
    page: Option<i32>,
    limit: Option<i32>,
    sorting: Option<Vec<models::CustomerOrderSortProperty>>,
) -> Result<models::ListResourceCustomerOrder, Error<CustomerPortalOrdersListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_product_id = product_id;
    let p_query_product_billing_type = product_billing_type;
    let p_query_subscription_id = subscription_id;
    let p_query_query = query;
    let p_query_page = page;
    let p_query_limit = limit;
    let p_query_sorting = sorting;

    let uri_str = format!("{}/v1/customer-portal/orders/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_product_id {
        req_builder = req_builder.query(&[("product_id", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_product_billing_type {
        req_builder =
            req_builder.query(&[("product_billing_type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_subscription_id {
        req_builder =
            req_builder.query(&[("subscription_id", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_query {
        req_builder = req_builder.query(&[("query", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sorting {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("sorting".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "sorting",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListResourceCustomerOrder`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListResourceCustomerOrder`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CustomerPortalOrdersListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Update an order for the authenticated customer.  **Scopes**: `customer_portal:write`
pub async fn customer_portal_orders_update(
    configuration: &configuration::Configuration,
    id: &str,
    customer_order_update: models::CustomerOrderUpdate,
) -> Result<models::CustomerOrder, Error<CustomerPortalOrdersUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_body_customer_order_update = customer_order_update;

    let uri_str = format!(
        "{}/v1/customer-portal/orders/{id}",
        configuration.base_path,
        id = crate::apis::urlencode(p_path_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_customer_order_update);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CustomerOrder`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CustomerOrder`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CustomerPortalOrdersUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a customer portal's organization by slug.
pub async fn customer_portal_organizations_get(
    configuration: &configuration::Configuration,
    slug: &str,
) -> Result<models::CustomerOrganization, Error<CustomerPortalOrganizationsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;

    let uri_str = format!(
        "{}/v1/customer-portal/organizations/{slug}",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CustomerOrganization`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CustomerOrganization`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CustomerPortalOrganizationsGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// **Scopes**: `customer_portal:write`
pub async fn customer_portal_seats_assign_seat(
    configuration: &configuration::Configuration,
    seat_assign: models::SeatAssign,
) -> Result<models::CustomerSeat, Error<CustomerPortalSeatsAssignSeatError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_seat_assign = seat_assign;

    let uri_str = format!("{}/v1/customer-portal/seats", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_seat_assign);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CustomerSeat`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CustomerSeat`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CustomerPortalSeatsAssignSeatError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// List all subscriptions where the authenticated customer has claimed a seat.  **Scopes**: `customer_portal:read` `customer_portal:write`
pub async fn customer_portal_seats_list_claimed_subscriptions(
    configuration: &configuration::Configuration,
) -> Result<
    Vec<models::CustomerSubscription>,
    Error<CustomerPortalSeatsListClaimedSubscriptionsError>,
> {
    let uri_str = format!(
        "{}/v1/customer-portal/seats/subscriptions",
        configuration.base_path
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::CustomerSubscription&gt;`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::CustomerSubscription&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CustomerPortalSeatsListClaimedSubscriptionsError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// **Scopes**: `customer_portal:read` `customer_portal:write`
pub async fn customer_portal_seats_list_seats(
    configuration: &configuration::Configuration,
    subscription_id: Option<&str>,
    order_id: Option<&str>,
) -> Result<models::SeatsList, Error<CustomerPortalSeatsListSeatsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_subscription_id = subscription_id;
    let p_query_order_id = order_id;

    let uri_str = format!("{}/v1/customer-portal/seats", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_subscription_id {
        req_builder = req_builder.query(&[("subscription_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order_id {
        req_builder = req_builder.query(&[("order_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SeatsList`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SeatsList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CustomerPortalSeatsListSeatsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// **Scopes**: `customer_portal:write`
pub async fn customer_portal_seats_resend_invitation(
    configuration: &configuration::Configuration,
    seat_id: &str,
) -> Result<models::CustomerSeat, Error<CustomerPortalSeatsResendInvitationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_seat_id = seat_id;

    let uri_str = format!(
        "{}/v1/customer-portal/seats/{seat_id}/resend",
        configuration.base_path,
        seat_id = crate::apis::urlencode(p_path_seat_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CustomerSeat`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CustomerSeat`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CustomerPortalSeatsResendInvitationError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// **Scopes**: `customer_portal:write`
pub async fn customer_portal_seats_revoke_seat(
    configuration: &configuration::Configuration,
    seat_id: &str,
) -> Result<models::CustomerSeat, Error<CustomerPortalSeatsRevokeSeatError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_seat_id = seat_id;

    let uri_str = format!(
        "{}/v1/customer-portal/seats/{seat_id}",
        configuration.base_path,
        seat_id = crate::apis::urlencode(p_path_seat_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CustomerSeat`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CustomerSeat`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CustomerPortalSeatsRevokeSeatError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Cancel a subscription of the authenticated customer.  **Scopes**: `customer_portal:write`
pub async fn customer_portal_subscriptions_cancel(
    configuration: &configuration::Configuration,
    id: &str,
) -> Result<models::CustomerSubscription, Error<CustomerPortalSubscriptionsCancelError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/v1/customer-portal/subscriptions/{id}",
        configuration.base_path,
        id = crate::apis::urlencode(p_path_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CustomerSubscription`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CustomerSubscription`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CustomerPortalSubscriptionsCancelError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a subscription for the authenticated customer.  **Scopes**: `customer_portal:read` `customer_portal:write`
pub async fn customer_portal_subscriptions_get(
    configuration: &configuration::Configuration,
    id: &str,
) -> Result<models::CustomerSubscription, Error<CustomerPortalSubscriptionsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/v1/customer-portal/subscriptions/{id}",
        configuration.base_path,
        id = crate::apis::urlencode(p_path_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CustomerSubscription`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CustomerSubscription`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CustomerPortalSubscriptionsGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// List subscriptions of the authenticated customer.  **Scopes**: `customer_portal:read` `customer_portal:write`
pub async fn customer_portal_subscriptions_list(
    configuration: &configuration::Configuration,
    product_id: Option<models::ProductIdFilter>,
    active: Option<bool>,
    query: Option<&str>,
    page: Option<i32>,
    limit: Option<i32>,
    sorting: Option<Vec<models::CustomerSubscriptionSortProperty>>,
) -> Result<models::ListResourceCustomerSubscription, Error<CustomerPortalSubscriptionsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_product_id = product_id;
    let p_query_active = active;
    let p_query_query = query;
    let p_query_page = page;
    let p_query_limit = limit;
    let p_query_sorting = sorting;

    let uri_str = format!(
        "{}/v1/customer-portal/subscriptions/",
        configuration.base_path
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_product_id {
        req_builder = req_builder.query(&[("product_id", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_active {
        req_builder = req_builder.query(&[("active", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_query {
        req_builder = req_builder.query(&[("query", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sorting {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("sorting".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "sorting",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListResourceCustomerSubscription`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListResourceCustomerSubscription`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CustomerPortalSubscriptionsListError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Update a subscription of the authenticated customer.  **Scopes**: `customer_portal:write`
pub async fn customer_portal_subscriptions_update(
    configuration: &configuration::Configuration,
    id: &str,
    customer_subscription_update: models::CustomerSubscriptionUpdate,
) -> Result<models::CustomerSubscription, Error<CustomerPortalSubscriptionsUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_body_customer_subscription_update = customer_subscription_update;

    let uri_str = format!(
        "{}/v1/customer-portal/subscriptions/{id}",
        configuration.base_path,
        id = crate::apis::urlencode(p_path_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_customer_subscription_update);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CustomerSubscription`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CustomerSubscription`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CustomerPortalSubscriptionsUpdateError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a wallet by ID for the authenticated customer.  **Scopes**: `customer_portal:read` `customer_portal:write`
pub async fn customer_portal_wallets_get(
    configuration: &configuration::Configuration,
    id: &str,
) -> Result<models::CustomerWallet, Error<CustomerPortalWalletsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/v1/customer-portal/wallets/{id}",
        configuration.base_path,
        id = crate::apis::urlencode(p_path_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CustomerWallet`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CustomerWallet`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CustomerPortalWalletsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// List wallets of the authenticated customer.  **Scopes**: `customer_portal:read` `customer_portal:write`
pub async fn customer_portal_wallets_list(
    configuration: &configuration::Configuration,
    page: Option<i32>,
    limit: Option<i32>,
    sorting: Option<Vec<models::CustomerWalletSortProperty>>,
) -> Result<models::ListResourceCustomerWallet, Error<CustomerPortalWalletsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_page = page;
    let p_query_limit = limit;
    let p_query_sorting = sorting;

    let uri_str = format!("{}/v1/customer-portal/wallets/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sorting {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("sorting".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "sorting",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListResourceCustomerWallet`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListResourceCustomerWallet`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CustomerPortalWalletsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
